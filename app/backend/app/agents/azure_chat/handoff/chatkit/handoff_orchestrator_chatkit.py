from typing import Any, AsyncGenerator
from collections.abc import AsyncIterable
from agent_framework import AgentRunResponseUpdate, AgentRunUpdateEvent, ChatAgent, FunctionApprovalRequestContent, FunctionCallContent,HandoffBuilder,InMemoryCheckpointStorage, RequestInfoEvent, TextContent,WorkflowCheckpoint, WorkflowEvent, HandoffUserInputRequest, FunctionApprovalResponseContent
from agent_framework.exceptions import AgentThreadException
from agent_framework.azure import AzureOpenAIChatClient
from app.agents.azure_chat.handoff.chatkit.account_agent_chatkit import AccountAgent
from app.agents.azure_chat.handoff.chatkit.transaction_agent_chatkit import TransactionHistoryAgent
from app.agents.azure_chat.handoff.chatkit.payment_agent_chatkit import PaymentAgent
from uuid import uuid4
import logging

logger = logging.getLogger(__name__)

class HandoffOrchestrator:
    
    triage_instructions = """
      You are a banking customer support agent triaging customer requests about their banking account, movements, payments.
      You have to evaluate the whole conversation with the customer and handoff to AccountAgent, TransactionHistoryAgent, PaymentAgent. 
      When delegation is required, call the matching handoff too based on triage rules.
      
      
      # Triage rules
      - If the user request is related to bank account information like account balance, payment methods, cards and beneficiaries book you must call handoff_to_AccountAgent.
      - If the user request is related to banking movements and payments history, you must call handoff_to_TransactionHistoryAgent.
      - If the user request is related to initiate a payment request, upload a bill or invoice image for payment or manage an on-going payment process, you must call handoff_to_PaymentAgent.
      - If the user request is not related to account, transactions or payments you must respond to the user that you are not able to help with the request.

      
    """

    """ A simple in-memory store [workflow_id/thread_id, WorkflowCheckpoint] to keep track of threads per user/session.
     Thread_id and workflow_id are synonymous in this context. We are keeping the thread_id concept and assign it the workflow_id value generated by the agent framework.
    In production, this should be replaced with a persistent store like a database or distributed cache.
    """
    thread_checkpoint_store: dict[str, WorkflowCheckpoint] = {}
    checkpoint_storage = InMemoryCheckpointStorage()

    def __init__(self, 
                 azure_chat_client: AzureOpenAIChatClient,
                 account_agent: AccountAgent,
                 transaction_agent: TransactionHistoryAgent,
                 payment_agent: PaymentAgent
                                ):
      self.azure_chat_client = azure_chat_client
      self.account_agent = account_agent
      self.transaction_agent = transaction_agent
      self.payment_agent = payment_agent
      self.workflow = None  # Will be initialized in async method

    async def initialize(self):
      """Initialize the workflow with async operations"""
      triage_agent = ChatAgent(
            chat_client=self.azure_chat_client,
            instructions=HandoffOrchestrator.triage_instructions,
            name="triage_agent"
        )
      
      self.workflow = (
        HandoffBuilder(
            name="banking_assistant_handoff",
            participants=[triage_agent, 
                          await self.account_agent.build_af_agent(),
                          await self.transaction_agent.build_af_agent(),
                          await self.payment_agent.build_af_agent()],
        )
        .set_coordinator("triage_agent")
        .with_termination_condition(
            # Terminate after 20 user messages 
            # Count only USER role messages to avoid counting agent responses
            lambda conv: sum(1 for msg in conv if msg.role.value == "user") >= 20
        )
        .with_checkpointing(HandoffOrchestrator.checkpoint_storage)
        .build()
    )

            
    
    async def _resume_workflow_with_response(self, checkpoint_id: str, user_message: str) -> AsyncIterable[WorkflowEvent]:
        """Resume a workflow from a checkpoint with a response to a RequestInfoEvent.

        Args:
            checkpoint (WorkflowCheckpoint): The checkpoint to resume from.
            response (dict[str, str]): The response mapping request IDs to user inputs.

        Yields:
            AsyncIterable[WorkflowEvent]: The events generated by resuming the workflow.
        """
        events = self.workflow.run_stream(checkpoint_id=checkpoint_id, checkpoint_storage=HandoffOrchestrator.checkpoint_storage) #type: ignore
        
        #We need to collect all workflow events otherwise we get concurrent workflow execution error when trying to resume.
        consumed_events = [event async for event in events]
        for event in consumed_events:
            if isinstance(event, RequestInfoEvent):
                if isinstance(event.data, HandoffUserInputRequest):
                        response = {event.request_id: user_message}
                        return self.workflow.send_responses_streaming(response) #type: ignore
                else:
                    raise AgentThreadException(f"RequestInfoEvent [{event.request_id}] found in the checkpoint [{checkpoint_id}] that is not a HandoffUserInputRequest.")

        #if we reach here, something went wrong. For this use case HandoffOrchestrator expected to always trigger a RequestInfoEvent.
        raise AgentThreadException(f"No RequestInfoEvent found in the checkpoint [{checkpoint_id}]")
            
    
    async def processMessageStream(self, user_message: str , thread_id : str | None) -> AsyncGenerator[WorkflowEvent,None]:
      
        #Agents are initialized asynchronously due to the use of MCP tools. So we can't initialize the workflow in __init__. We do it lazily here.
        if self.workflow is None:
                await self.initialize()
     
         
        checkpoint = None
        events = None

        # try to retrieve checkpoint for the given thread_id. If None, we start a new conversation.
        checkpoint = HandoffOrchestrator.thread_checkpoint_store.get(thread_id, None) if thread_id else None
        workflow_id = self.workflow.id  # type: ignore

        if checkpoint is None:
            # Start a new conversation. This is the first user message.

            async for event in self.workflow.run_stream(user_message):# type: ignore
                #it's not final and does not have thread id yet
                yield event # type: ignore
        else:
            #Resuming an existing conversation.
            workflow_id = checkpoint.workflow_id
            async for event in await self._resume_workflow_with_response(checkpoint.checkpoint_id, user_message):
                # it's not final and does not have thread id yet
                yield event

        #Saving the last checkpoint for the conversation thread
        checkpoints = await HandoffOrchestrator.checkpoint_storage.list_checkpoints(workflow_id=workflow_id) # type: ignore
        last_checkpoint = checkpoints[-1] if checkpoints else None
        if last_checkpoint is None:
         raise AgentThreadException(f"No checkpoint found after completing the first conversation for workflow_id: {workflow_id}") # type: ignore

        #saving the last checkpoint for the conversation thread us
        HandoffOrchestrator.thread_checkpoint_store[thread_id] = last_checkpoint # type: ignore

    async def processToolApprovalResponse(self, thread_id: str, approved:bool, call_id: str, request_id: str, tool_name: str) -> AsyncGenerator[WorkflowEvent,None]:
        """Process a tool approval response from the user.

        Args:
            thread_id (str): The thread ID associated with the workflow.
            approved (bool): Whether the user approved the tool execution.

        """

        if self.workflow is None:
               await self.initialize()
       

        checkpoint = HandoffOrchestrator.thread_checkpoint_store.get(thread_id, None)
        if checkpoint is None:
            raise AgentThreadException(f"No checkpoint found for thread_id: {thread_id} when trying to process tool approval response")
        
        events = self.workflow.run_stream(checkpoint_id=checkpoint.checkpoint_id, checkpoint_storage=HandoffOrchestrator.checkpoint_storage) #type: ignore
        
        #restart the workflow to get the reference to FunctionApprovalRequestEvent
        consumed_events = [event async for event in events]
        for event in consumed_events:
            if isinstance(event, RequestInfoEvent):
                if isinstance(event.data, FunctionApprovalRequestContent):
                        # function_call_content = FunctionCallContent(call_id=call_id, name=tool_name)
                        # response = FunctionApprovalResponseContent(
                        #     approved=approved,
                        #     id= request_id,
                        #     function_call=function_call_content
                        #     )
                        #response = {event.request_id: response}
                        response = {event.request_id: event.data.create_response(approved=approved)}
                        async for event in self.workflow.send_responses_streaming(response) : #type: ignore
                            yield event
                else:
                    raise AgentThreadException(f"RequestInfoEvent [{event.request_id}] found in the checkpoint [{checkpoint.checkpoint_id}] that is not a HandoffUserInputRequest.")
        